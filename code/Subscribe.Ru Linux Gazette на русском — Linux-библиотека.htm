<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
<title>Subscribe.Ru : Linux Gazette на русском — Linux-библиотека</title>

<meta content="text/html; charset=windows-1251" http-equiv="content-type">
<!--<link rel="stylesheet" type="text/css" href="/main.css">-->
<style type="text/css">
  div.stat {position:absolute; left:0px; top:0px; visibility:hidden;}
  div.stat img {width:0; height:0;}

	div.cont-left {width:30%; float:left;}
	div.cont-right {width:70%; float:right;}
  div.menu {padding:0 10px;}
  div.cont {padding:0 10px 30px 10px;}
  div.adv {font-size:0.9em; padding:5px 0 25px 0;}

  .collapsible-link {color:black; text-decoration:none;}

  .block_links * {
      background:transparent none repeat scroll 0 0 !important;
      border:medium none !important;
      clear:none !important;
      clip:rect(auto, auto, auto, auto) !important;
      font-size:100% !important;
      font-style:normal !important;
      font-variant:normal !important;
      font-weight:normal !important;
      height:auto !important;
      letter-spacing:normal !important;
      line-height:normal !important;
      margin:0 !important;
      overflow:visible !important;
      padding:0 !important;
      position:static !important;
      text-align:left !important;
      text-decoration:none !important;
      text-indent:0 !important;
      text-transform:none !important;
      vertical-align:baseline !important;
      visibility:visible !important;
      white-space:normal !important;
      width:auto;
      word-spacing:normal !important;
      z-index:auto !important;
      cursor: pointer!important;
      word-wrap: break-word!important;
  }
  .block_links li {
      display:list-item !important;
      list-style-image:none !important;
      list-style-position:outside !important;
      list-style-type:none !important;
      display: inline;
  }
  .block_links li DIV {
      padding:0.5em !important;
  }
  .block_links DIV, .block_links TABLE {
      padding: 5px !important;
  }
  .block_links {
      width: auto!important;
      font-family: Verdana!important;
      font-size: 11px!important;
      border: 1px solid #DDDDDD!important;
      background-color: #FFFFFF!important;
      padding:5px!important;
      position: relative!important;
      display:block!important;

      -webkit-border-radius:5px !important;
      -khtml-border-radius:5px !important;
      -moz-border-radius:5px !important;
      border-radius:5px !important;
  }
  .block_links_icnt, .block_links_icnt * {
      text-align: left!important;
  }

  .block_links_text, .block_links_text A, .block_links_text A:hover {
      color: #000000!important;
      font-size: 11px!important;
      text-decoration: none!important;
  }
  .block_links_url {
      color: #006600!important;
      font-size: 11px!important;
      text-decoration: none!important;
  }
  .block_links_header, .block_links_header A {
      color: #000066!important;
      font-size: 13px!important;
      font-weight: bold!important;
      text-decoration: underline!important;
  }
  .block_links_sign {
      color: #999999!important;
      font-size: 10px!important;
      text-align: left!important;
      text-decoration: none!important;
  }
  .block_links_clear {
      clear:both!important;
  }
  .block_links TABLE {
      width: 100%!important;
      border: 0px!important;
  }

  div.lf {
      padding:10px 10px 10px 10px;
      margin-bottom:10px;
      /*color:#000066;*/

      border: 1px solid #DDDDDD!important;
      -webkit-border-radius:5px !important;
      -khtml-border-radius:5px !important;
      -moz-border-radius:5px !important;
      border-radius:5px !important;
  }
  div.lf a {
      color:#000066;
      /*font-size:11px;*/
      /*text-decoration: none!important;*/
  }
</style>
<script async="async" src="https://w.uptolike.com/widgets/v1/zp.js?pid=1972021" type="text/javascript"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    $(".collapsible-link").next().hide();
    $(".collapsible-link").text("\u21E9");
    $(".collapsible-link").bind("click", function(e) {
      $(this).next().toggle();
      $(this).text( $(this).text() == "\u21E9" ? "\u21E7" : "\u21E9" );
      e.preventDefault();
    });
  });
</script>
</head>

<body>

<div class="cont-left">
  <div class="menu">
    <a href="/"><img src="/images/logo.png" width="344" height="80" border="0"></a><br><br>

    <B><a href="/"># Главная</a></B><BR>
    <B><a href="/about.htm"># О библиотеке</a></B><BR><BR>

    <B><a href="/distr/index.htm"># Выбор дистрибутива</a></B><BR>
    <FONT SIZE="-1">
    <A HREF="/distr/index.htm#linux">преимущества Linux/UNIX</a> |
    <A HREF="/distr/index.htm#general">основные дистрибутивы</a> |
    <A HREF="/distr/index.htm#server">серверный Linux</a> |
    <A HREF="/distr/index.htm#bsd">BSD</a> |
    <A HREF="/distr/index.htm#livecds">LiveCDs</a> |
    <A HREF="/distr/index.htm#other">прочее</A></FONT><BR><BR>

    <B><a href="/inst/index.htm"># Установка и удаление программ</a></B><BR>
    <FONT SIZE="-1">
    <A HREF="/inst/index.htm#linux">общие вопросы</a> |
    <A HREF="/inst/index.htm#general">каталоги софта</a> |
    <A HREF="/inst/index.htm#server">специальные случаи</A></FONT><BR><BR>

    <B><a href="/Linux/index.htm"># Настройка и работа</a></B><BR>
    <FONT SIZE="-1">
    <A HREF="/Linux/index.htm#loading">установка, загрузчики</A> |
    <A HREF="/Linux/index.htm#setting">настройка Linux</A> |
    <A HREF="/Linux/index.htm#console">консоль</A> |
    <A HREF="/Linux/index.htm#filesys">файловые системы</A> |
    <A HREF="/Linux/index.htm#proc">процессы</A> |
    <A HREF="/Linux/index.htm#shells">шеллы, русификация, коммандеры</A> |
    <A HREF="/Linux/index.htm#virtual">виртуальные машины, эмуляторы</A></FONT><BR><BR>

    <B><a href="/xwin/index.htm"># X Window и оконные менеджеры</a></B><BR>
    <FONT SIZE="-1">
    <A HREF="/xwin/index.htm#xwin">настройка X Window</a> |
    <A HREF="/xwin/index.htm#gnome">GNOME</a> |
    <A HREF="/xwin/index.htm#kde">KDE</a> |
    <A HREF="/xwin/index.htm#other">IceWM и др.</A></FONT><BR><BR>

    <B><a href="/text/index.htm"># Работа с текстами</a></B><BR>
    <FONT SIZE="-1">
    <A HREF="/text/index.htm#edit">редакторы</a> |
    <A HREF="/text/index.htm#office">офис</a> |
    <A HREF="/text/index.htm#local">шрифты, кодировки и русификация</a> |
    <A HREF="/text/index.htm#conv">преобразования текстовых файлов</a> |
    <A HREF="/text/index.htm#sgml">LaTeX, SGML и др.</a> |
    <A HREF="/text/index.htm#dict">словари</A></FONT><BR><BR>

    <B><a href="/gimp/index.htm"># Графика</a></B><BR>
    <FONT SIZE="-1">
    <A HREF="/gimp/index.htm#gimp">GIMP</a> |
    <A HREF="/gimp/index.htm#photo">фото</a> |
    <A HREF="/gimp/index.htm#imgproc">обработка изображений</a> |
    <A HREF="/gimp/index.htm#formats">форматы графических файлов</A></FONT><BR><BR>

    <B><a href="/net/index.htm"># Сети, администрирование</a></B><BR>
    <FONT SIZE="-1">
    <A HREF="/net/index.htm#tcp-ip">общие вопросы</a> |
    <A HREF="/net/index.htm#ppp">Dialup &amp; PPP</a> |
    <A HREF="/net/index.htm#firewall">брандмауэры</a> |
    <A HREF="/net/index.htm#route">маршрутизация</a> |
    <A HREF="/net/index.htm#winnet">работа в Windows-сетях</a> |
    <A HREF="/net/index.htm#www">веб-серверы</a> |
    <A HREF="/net/index.htm#apache">Apache</a> |
    <A HREF="/net/index.htm#proxy">прокси-серверы</a> |
    <A HREF="/net/index.htm#print">сетевая печать</a> |
    <A HREF="/net/index.htm#other">прочее</A></FONT><BR><BR>

    <B><a href="/prog/index.htm"># Программирование</a></B><BR>
    <FONT SIZE="-1">
    <A HREF="/prog/index.htm#gnu">GCC &amp; GNU make</a> |
    <A HREF="/prog/index.htm#unixprog">программирование в UNIX</a> |
    <A HREF="/prog/index.htm#gl">графические библиотеки</a> |
    <A HREF="/prog/index.htm#tcl">Tcl</a> |
    <A HREF="/prog/index.htm#perl">Perl</a> |
    <A HREF="/prog/index.htm#php">PHP</a> |
    <A HREF="/prog/index.htm#java">Java &amp; C#</a> |
    <A HREF="/prog/index.htm#dbms">СУБД</a> |
    <A HREF="/prog/index.htm#cvs">CVS</a> |
    <A HREF="/prog/index.htm#other">прочее</A></FONT><BR><BR>

    <a href="/kern/index.htm"># Ядро</a>
    <br><a href="/mmedia/index.htm"># Мультимедиа</a>
    <br><a href="/internet/index.htm"># Интернет</a>
    <br><a href="/post/index.htm"># Почта</a>
    <br><a href="/secur/index.htm"># Безопасность</a>
    <br><a href="/iron/index.htm"># Железо</a>
    <br><a href="/other/index.htm"># Разное</a><br><br>

    <a href="/HowTo/index.htm"><b># Linux HowTo (как сделать)</b></a><br>
    <a href="/indexbook.htm"><b># Книги и руководства</b></a><br>
    <a href="/en/index.htm"><b># Материалы на английском языке</b></a>

                <div class="adv">
      <script async="async" src="https://w.uptolike.com/widgets/v1/zp.js?pid=lfc4a8db38f70133e1ecc1f8a448b1f0d111ccfe83" type="text/javascript"></script>      

<!-- SAPE RTB JS -->
<script
    async="async"
    src="https://cdn-rtb.sape.ru/teasers/js/419/2/126419.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->          </div>


  </div>
</div>

<div class="cont-right">
  <div class="cont">
<CENTER><FONT size=4><B>Программирование с Xlib на C++</B><BR></FONT>&nbsp;<BR>Автор: (C) <A href="/cdn-cgi/l/email-protection#b6c4d9d4c2f6c4d9d4c2d9c3d1ded3c498d5d9db">Rob Tougher</A><BR>Перевод: (C) <A href="/cdn-cgi/l/email-protection#7813110b2719163815191114560a0d">Андрей Киселев</A>
</CENTER>
<HR noShade SIZE=2>

<DL>
  <DT><A href="#1">1. Введение</A>
  <DT><A href="#2">2. Почему не используются визуальные элементы (виджеты)?</A>
  <DT><A href="#3">3. Основы</A>
  <DD><A href="#3.1">3.1 Открытие дисплея</A>
  <DD><A href="#3.2">3.2 Создание окна</A>
  <DD><A href="#3.3">3.3 Обработка событий</A>
  <DD><A href="#3.4">3.4 Рисование</A>
  <DT><A href="#4">4. Создание кнопки</A>
  <DD><A href="#4.1">4.1 Требования к кнопке</A>
  <DD><A href="#4.2">4.2 Создание собственного окна</A>
  <DD><A href="#4.3">4.3 Реализация состояний "нажатая" и "отпущенная"</A>
  <DD><A href="#4.4">4.4 Дополнительные аспекты при отображении состояния
  кнопки</A>
  <DD><A href="#4.5">4.5 Свойство "text"</A>
  <DD><A href="#4.6">4.6 Генерация события "on_click()"</A>
  <DT><A href="#5">5. Заключение</A>
  <DT><A href="#a">a. Ссылки</A>
  <DT><A href="#b">b. Файлы</A> </DT></DL><A name=1></A>
<H2>1. Введение</H2>
<P>Xlib -- это библиотека, позволяющая программам на языке C рисовать на экране
любого X-сервера -- локального или удаленного. Все, что для этого требуется --
вставить в исходный файл программы строку "include &lt;X11/Xlib.h&gt;", добавить
в Makefile ключ компоновщика <TT>-lX11</TT>, и вот вы уже готовы к вызову любой
функции из библиотеки Xlib.</P>
<P>Для примера рассмотрим как нарисовать окно на экране локального компьютера.
Это можно сделать следующим образом: </P>
<P>Listing 1: <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/example1.cpp.txt">-->http://gazette.linux.ru.net/lg78/articles/misc/tougher/example1.cpp.txt<!--</A>--></P><PRE>#include &lt;X11/Xlib.h&gt;
#include &lt;unistd.h&gt;

main()
{
  // Открыть дисплей
  Display *d = XOpenDisplay(0);

  if ( d )
    {
      // Создать окно
      Window w = XCreateWindow(d, DefaultRootWindow(d), 0, 0, 200,
                    100, 0, CopyFromParent, CopyFromParent,
                    CopyFromParent, 0, 0);

      // Нарисовать окно на экране
      XMapWindow(d, w);
      XFlush(d);

      // Выполнить задержку, достаточную
      // по времени, чтобы мы смогли увидеть окно
      sleep(10);
    }
  return 0;
}
</PRE>
<P>Скомпилируйте программу командой: </P><PRE>prompt$ g++ test.cpp -L/usr/X11R6/lib -lX11
</PRE>
<P>Запустите:</P><PRE>prompt$ ./a.out
</PRE>
<P>И, вуаля, в течение 10 секунд можете любоваться окном на экране:</P>
<P>Рисунок. Если очень хочется -- можнопосмотреть на <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/screen_small.png">-->http://gazette.linux.ru.net/lg78/articles/misc/tougher/screen_small.png<!--</A>--></P>
<P>Цель данной статьи - познакомить вас с некоторыми простыми классами, которые
можно использовать при разработке Xlib-приложений. Мы создадим приложение с
одним окном и кнопкой в этом окне. Кнопку мы напишем сами, используя только
библиотеку Xlib. </P><A name=2></A>
<H2>2. Почему не используются визуальные элементы (виджеты)?</H2>
<P>Вы можете задаться вопросом: "А почему бы не использовать библиотеки
визуальных элементов (виджетов), скажем <!--<A href="http://www.trolltech.com/">-->QT
(http://www.trolltech.com/)<!--</A>--> или <!--<A href="http://www.gtk.org/">-->GTK
(http://www.gtk.org/)<!--</A>-->?". Законный вопрос. Я использую QT, и нахожу ее очень
удобной для разработки приложений на C++ для платформы Linux.</P>
<P>Причина, по которой я пишу эти строки, заключается в намерении дать вам более
глубокое понимание X Window System, а для этого нужно заглянуть под покров
библиотек QT и GTK. Несколько раз уже я приходил к выводу, что умение писать
Xlib приложения действительно <I>полезно</I>.</P>
<P>Я надеюсь, что эта статья поможет вам использовать имеющиеся классы в ваших
приложениях.</P><A name=3></A>
<H2>3. Основы</H2>
<P>В этом разделе мы пройдемся по основным особенностям библиотеки Xlib. Давайте
сейчас рассмотрим исходный код примера.</P><A name=3.1></A>
<H3>3.1 Открытие дисплея</H3>
<P>Первый класс, который создается в программе -- это класс <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/display.hpp.txt">-->display
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/display.hpp.txt)<!--</A>-->,
основная задача которого -- открытие и закрытие дисплея. Заметьте, что в примере
examle1.cpp, дисплей не закрывается явно с помощью вызова XCloseDisplay().
Дисплей будет закрыт самим классом display перед завершением программы. Немножко
усложним наш пример, и он уже выглядит вот так:</P>
<P>Listing 2: <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/example2.cpp.txt">-->http://gazette.linux.ru.net/lg78/articles/misc/tougher/example2.cpp.txt<!--</A>--></P><PRE>#include &lt;unistd.h&gt;

<B>#include "xlib++/display.hpp"
using namespace xlib;</B>

main()
{
  <B>try
    {</B>
      // Открыть дисплей
      <B>display d("");</B>

      // Создать окно
      Window w = XCreateWindow(<B>(Display*)d</B>,
                    DefaultRootWindow(<B>(Display*)d</B>),
                    0, 0, 200, 100, 0, CopyFromParent,
                    CopyFromParent, CopyFromParent, 0, 0);

      // Нарисовать окно на экране
      XMapWindow(d, w);
      XFlush(d);

      // Выполнить задержку, чтобы успеть увидеть окно
      sleep(10);
    }
  <B>catch ( open_display_exception&amp; e )
    {
      std::cout &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; "\n";
    }</B>
  return 0;
}
</PRE>
<P>Собственно, ничего особенного. Все то же самое -- открывается и закрывается
дисплей. Однако, вы наверняка заметили, что экземпляр класса display в данной <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/display.hpp.txt">-->реализации
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/display.hpp.txt)<!--</A>-->
приводится к типу Display*, таким образом, создавая экземпляр этого класса , вы
в действительности получаете указатель на Xlib Display. </P>
<P>Конечно же вы заметили и блок try/catch. Все классы в данной статье для
извещения об ошибках порождают исключения.</P><A name=3.2></A>
<H3>3.2 Создание окна</H3>
<P>Далее, я хотел бы упростить процесс создания окна, для этого я добавлю класс
<!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/window.hpp.txt">-->window
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/window.hpp.txt)<!--</A>-->.
Этот класс создает и отрисовывает окно в конструкторе, а "разрушает" окно в
деструкторе. Теперь пример выглядит так (обратите внимание на класс
event_dispatcher, который мы рассмотрим несколько ниже): </P>
<P>Listing 3 : <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/example3.cpp.txt">-->http://gazette.linux.ru.net/lg78/articles/misc/tougher/example3.cpp.txt<!--</A>--></P><PRE>#include "xlib++/display.hpp"
<B>#include "xlib++/window.hpp"</B>
using namespace xlib;

<B>class main_window : public window
{
 public:
  main_window ( event_dispatcher&amp; e ) : window ( e ) {};
  ~main_window(){};
};</B>

main()
{
  try
    {
      // Открыть дисплей
      display d("");

      <B>event_dispatcher events ( d );
      main_window w ( events ); // верхний уровень
      events.run();</B>
    }
  catch ( exception_with_text&amp; e )
    {
      std::cout &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; "\n";
    }
  return 0;
}
</PRE>
<P>Обратите внимание на то, что наш класс <B>main_window</B> порожден от класса
<B>xlib::window</B>. Когда создается объект main_window, вызывается базовый
конструктор, который создает окно Xlib.</P><A name=3.3></A>
<H3>3.3 Обработка событий</H3>
<P>Вы наверняка обратили внимание на класс <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/event_dispatcher.hpp.txt">-->event_dispatcher
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/event_dispatcher.hpp.txt
) <!--</A>-->в последнем примере. Этот класс получает события из очереди событий
приложения и передает их требуемому окну.</P>
<P>Определен этот класс следующим образом:</P>
<P>Listing 4 : <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/event_dispatcher.hpp.txt">-->http://gazette.linux.ru.net/lg78/articlesmisc/tougher/event_dispatcher.hpp.txt
<!--</A>--></P><PRE>    class event_dispatcher
    {
    // constructor, destructor, and others...
        [snip...]

        register_window ( window_base *p );
        unregister_window ( window_base *p );
        run();
        stop();
        handle_event ( event );
    }
</PRE>
<P>Класс event_dispatcher передает события классу окна через интерфейс класса <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/window_base.hpp.txt">-->window_base
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/window_base.hpp.txt)<!--</A>-->.
Все классы окон, в этой статье, являются наследниками именно этого класса и,
после регистрации себя вызовом метода <B>register_window</B>, могут получать
сообщения от диспетчера. Из объявления класса <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/window_base.hpp.txt">-->window_base
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/window_base.hpp.txt)
<!--</A>-->следует, что все классы, порождаемые от него, смогут получать события,
реализовав следующие методы:</P>
<P>Listing 5 : <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/window_base.hpp.txt">-->window_base.hpp
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/window_base.hpp.txt)<!--</A>--></P><PRE>      virtual void on_expose() = 0;

      virtual void on_show() = 0;
      virtual void on_hide() = 0;

      virtual void on_left_button_down ( int x, int y ) = 0;
      virtual void on_right_button_down ( int x, int y ) = 0;

      virtual void on_left_button_up ( int x, int y ) = 0;
      virtual void on_right_button_up ( int x, int y ) = 0;

      virtual void on_mouse_enter ( int x, int y ) = 0;
      virtual void on_mouse_exit ( int x, int y ) = 0;
      virtual void on_mouse_move ( int x, int y ) = 0;

      virtual void on_got_focus() = 0;
      virtual void on_lost_focus() = 0;

      virtual void on_key_press ( character c ) = 0;
      virtual void on_key_release ( character c ) = 0;

      virtual void on_create() = 0;
      virtual void on_destroy() = 0;
</PRE>
<P>Давайте проверим, а так ли это в действительности? Попробуем обработать
событие ButtonPress в нашем окне. Добавим в определение нашего класса
main_window следующий код:</P>
<P>Listing 6 : <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/example4.cpp.txt">-->example4.cpp
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/example4.cpp.txt)<!--</A>--></P><PRE>class main_window : public window
{
 public:
  main_window ( event_dispatcher&amp; e ) : window ( e ) {};
  ~main_window(){};

  <B>void on_left_button_down ( int x, int y )
  {
    std::cout &lt;&lt; "on_left_button_down()\n";
  }</B>

};
</PRE>
<P>Скомпилируйте и запустите приложение, а потом щелкните в окне мышкой. Код
сработал! Класс event_dispatcher получил событие ButtonPress и передал его в
наше окно через вызов предопределенного метода <B>on_left_button_down</B>.</P><A
name=3.4></A>
<H3>3.4 Рисование</H3>
<P>Теперь попробуем рисовать в нашем окне. Система X Window определяет концепцию
"графического контекста" ("graphics context"), поэтому я, естественно, создаю
класс <B>graphics_context</B>. Вот определение класса:</P>
<P>Listing 7 : <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/graphics_context.hpp.txt">-->graphics_context.hpp
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/graphics_context.hpp.txt)<!--</A>--></P><PRE>  class graphics_context
    {
    public:
      graphics_context ( display&amp; d, int window_id );
      ~graphics_context();

      void draw_line ( line l );
      void draw_rectangle ( rectangle rect );
      void draw_text ( point origin, std::string text );
      void fill_rectangle ( rectangle rect );
      void set_foreground ( color&amp; c );
      void set_background ( color&amp; c );
      rectangle get_text_rect ( std::string text );
      std::vector&lt;int&gt; get_character_widths ( std::string text );
      int get_text_height ();
      long id();

    private:

      display&amp; m_display;
      int m_window_id;
      GC m_gc;
    };
</PRE>
<P>Передав этому классу id окна и объект display, вы, используя для этого
соответствующие методы, получаете возможность рисовать на поверхности окна.
Давайте попробуем. Добавьте в наш пример следующий код:</P>
<P>Listing 8 : <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/example5.cpp.txt">-->example5.cpp
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/example5.cpp.txt)<!--</A>--></P><PRE>#include "xlib++/display.hpp"
#include "xlib++/window.hpp"
<B>#include "xlib++/graphics_context.hpp"</B>
using namespace xlib;


class main_window : public window
{
 public:
  main_window ( event_dispatcher&amp; e ) : window ( e ) {};
  ~main_window(){};

  <B>void on_expose ()
  {
    graphics_context gc ( get_display(),id() );

    gc.draw_line ( line ( point(0,0), point(50,50) ) );
    gc.draw_text ( point(0, 70), "I'm drawing!!" );
  }</B>

};
</PRE>
<P>Метод <B>on_expose()</B> вызывается всякий раз, когда окно выводится на
экран. Внутри этого метода я разместил код, на поверхности окна (в клиентской
его области) рисующий линию и выводящий некоторый текст. Когда вы скомпилируете
и запустите этот пример, то вы должны увидеть примерно следующее: </P>
<P>Рисунок на <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/draw_line.png">-->http://gazette.linux.ru.net/lg78/articles/misc/tougher/draw_line.png<!--</A>--></P>
<P>Класс <B>graphics_context</B> широко используется в данной статье.</P>
<P>Вы могли заметить в выше приведенном коде два вспомогательных класса: <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/shapes.hpp.txt">-->point
и line
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/shapes.hpp.txt)<!--</A>-->. Эти
маленькие классы, которые я создал для упрощения построения фигур. Сейчас они не
столь необходимы, но позднее, когда потребуется выполнять комплексные операции
типа трансформации фигур, они окажутся полезными. Например, куда как проще
написать "line.move_x(5)", чем "line_x += 5; line_y += 5;". И проще, и ниже
вероятность допустить ошибку.</P><A name=4></A>
<H2>4. Создание кнопки</H2><A name=4.1></A>
<H3>4.1 Требования к кнопке</H3>
<P>Давайте приступим к созданию визуального элемента, который потом может быть
использован в других наших программах. Требования к кнопке можно выразить
так:</P>
<UL>
  <LI>должна иметь свое окно для приема событий
  <LI>должна иметь два состояния -- "нажатая кнопка" и "отпущенная кнопка"
  <LI>должна отображаться как "нажатая" при нажатии на нее кнопкой мыши (т.е.
  когда указатель мыши неподвижно расположен над кнопкой)
  <LI>должна отображаться как "ненажатая" если кнопка мыши отпущена, либо когда
  указатель мыши находится вне пределов кнопки
  <LI>должна иметь свойство text и методы get и set для управления им
  <LI>должна передавать клиенту событие "on_click()" </LI></UL>
<P>Выглядит довольно просто, но реализация всего этого не столь тривиальная
задача.</P><A name=4.2></A>
<H3>4.2 Создание собственного окна</H3>
<P>Для начала создается отдельное окно кнопки. Конструктор вызывает метод
<B>show</B>, который в свою очередь передает управление методу <B>create</B>,
ответственному за создание окна:</P>
<P>Listing 9 : <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txt">-->command_button.hpp
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txt)<!--</A>--></P><PRE>    virtual void create()
    {
        if ( m_window ) return;

        m_window = XCreateSimpleWindow ( m_display, m_parent.id(),
                        m_rect.origin().x(),
                        m_rect.origin().y(),
                        m_rect.width(),
                        m_rect.height(),
                        0, WhitePixel((void*)m_display,0),
                        WhitePixel((void*)m_display,0));

        if ( m_window == 0 )
        {
            throw create_button_exception( "could not create the command button" );
        }

        m_parent.get_event_dispatcher().register_window ( this );
        set_background ( m_background );
    }
</PRE>
<P>Очень похоже на конструктор класса <B>window</B>, не так ли? Первым делом
создается окно с помощью вызова Xlib API XCreateSimpleWindow(), затем окно
регистрируется в event_dispatcher, включаясь тем самым в цикл обработки событий,
и наконец -- устанавливается фон. </P>
<P>Примечательно, что в XCreateSimpleWindow() передается id родительского окна,
тем самым сообщая Xlib, что кнопка является дочерним окном указанного
родителя.</P><A name=4.3></A>
<H3>4.3 Реализация состояний "нажатая" и "отпущенная"</H3>
<P>Поскольку кнопка регистрирует свое окно в event_dispatcher, появляется
возможность при необходимости перерисовки получать события <B>on_expose()</B>.
Для отображения обоих состояний кнопки используется класс
<B>graphics_context</B>. </P>
<P>Ниже показан ход отображения "отпущенной" кнопки</P>
<P>Listing 10 : <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txt">-->command_button.hpp
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txt)<!--</A>--></P><PRE>      // нижняя грань
      gc.draw_line (    line ( point(0, rect.height()-1),
                        point(rect.width()-1,
                        rect.height()-1) ) );
      // правая грань
      gc.draw_line ( line ( point ( rect.width()-1, 0 ),
                            point ( rect.width()-1,
                            rect.height()-1 ) ) );

      gc.set_foreground ( white );

      // верхняя грань
      gc.draw_line ( line ( point ( 0,0 ), point ( rect.width()-2, 0 ) ) );
      // левая грань
      gc.draw_line ( line ( point ( 0,0 ), point ( 0, rect.height()-2 ) ) );

      gc.set_foreground ( gray );

      // серая полутень нижней грани
      gc.draw_line ( line ( point ( 1, rect.height()-2 ),
                point(rect.width()-2,rect.height()-2) ) );
      // серая полутень правой грани
      gc.draw_line ( line ( point ( rect.width()-2, 1 ),
                point(rect.width()-2,rect.height()-2) ) );
</PRE>
<P>После компиляции и запуска приложения, кнопка будет выглядеть примерно
так:</P>
<P>Рисунок на <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.png">-->http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.png<!--</A>--></P>
<P>Следующий фрагмент кода рисует "нажатую" кнопку:</P>
<P>Listing 11 : <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txt">-->command_button.hpp
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txt)<!--</A>--></P><PRE>      gc.set_foreground ( white );

      // нижняя грань
      gc.draw_line ( line ( point(1,rect.height()-1),
            point(rect.width()-1,rect.height()-1) ) );
      // правая грань
      gc.draw_line ( line ( point ( rect.width()-1, 1 ),
            point ( rect.width()-1, rect.height()-1 ) ) );

      gc.set_foreground ( black );

      // верхняя грань
      gc.draw_line ( line ( point ( 0,0 ),
            point ( rect.width()-1, 0 ) ) );
      // левая грань
      gc.draw_line ( line ( point ( 0,0 ),
            point ( 0, rect.height()-1 ) ) );


      gc.set_foreground ( gray );

      // серая полутень верхней грани
      gc.draw_line ( line ( point ( 1, 1 ),
            point(rect.width()-2,1) ) );
      // серая полутень левой грани
      gc.draw_line ( line ( point ( 1, 1 ),
            point( 1, rect.height()-2 ) ) );
</PRE>
<P>Нажатая кнопка выглядит так:</P>
<P>Рисунок на <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txthttp://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button_pressed.png">-->http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button_pressed.png<!--</A>-->
</P><A name=4.4></A>
<H3>4.4 Дополнительные аспекты при отображении состояния кнопки</H3>
<P>Казалось бы, все довольно просто: когда над кнопкой нажимается клавиша мыши
-- рисуется "нажатая" кнопка, а когда клавиша мыши отпускается -- рисуется
"отпущенная". Однако это не совсем верно. Если над изображением кнопки
нажимается, а затем удерживается в нажатом состоянии, левая клавиша мыши, а
после этого указатель мыши перемещается за пределы кнопки, то, не смотря на то,
что клавиша мыши остается нажатой, кнопка должна отобразить состояние
"отпущенная". </P>
<P>Для обработки такой ситуации класс <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txt">-->command_button
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txt)<!--</A>-->
имеет два поля -- <B>m_is_down</B> и <B>m_is_mouse_over</B>. Сначала, нажатие
клавиши мыши над кнопкой (смотри <B>on_left_button_down()</B>) переводит ее в
состояние "нажатая" и перерисовывает ее, затем, если курсор мыши выводится за
пределы кнопки (смотри <B>on_mouse_exit()</B>), то поле <B>m_is_mouse_over</B>
устанавливается в состояние false и кнопка опять перерисовывается, но уже как
"отпущенная". Если теперь курсор мыши опять переместить на кнопку, то поле
<B>m_is_mouse_over</B> перейдет в состояние true и кнопка будет перерисована как
"нажатая". Когда клавиша мыши отпускается, то кнопка переводится в состояние
"отпущенная" и перерисовывается. </P><A name=4.5></A>
<H3>4.5 Свойство "text"</H3>
<P>Реализация свойства "text" -- довольно простая задача. Для управления этим
свойством в распоряжение программиста предоставляется два метода: первый --
получить текст надписи на кнопке, второй -- изменить его: </P>
<P>Listing 12 : <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txt">-->command_button.hpp
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txt)<!--</A>--></P><PRE>      std::string get_name() { return m_name; }
      void set_name ( std::string s ) { m_name = s; refresh(); }
</PRE>
<P>Вызов метода <B>refresh()</B> служит для отображения кнопки с обновленной
надписью.</P><A name=4.6></A>
<H3>4.6 Генерация события "on_click()"</H3>
<P>Теперь необходимо снабдить нашу кнопку возможностью порождать событие
"on_click()" в тот момент, когда по ней производится щелчок мышью. Ниже
приведено определение класса <B>command_button_base</B>:</P>
<P>Listing 13 : <!--<A
href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button_base.hpp.txt">-->command_button_base.hpp
(http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button_base.hpp.txt)<!--</A>--></P><PRE>namespace xlib
{
  class command_button_base : public window_base
    {
    public:
      virtual void on_click () = 0;
    };
};
</PRE>
<P>По существу этот код утверждает: "кнопка поддерживает все события, которые
поддерживает класс окна, плюс еще одно -- on_click()". В результате, породив
дочерний класс, программист получает возможность реализовать метод
<B>on_click()</B> для выполнения необходимых действий. </P><A name=5></A>
<H2>5. Заключение</H2>
<P>Я надеюсь, что вам понравилась эта статья. Мы рассмотрели некоторые из
свойств библиотеки Xlib и "завернули" их в классы C++, чтобы сделать разработку
программ на основе Xlib проще. Если у вас есть какие либо вопросы, комментарии
или предложения по данной статье или по работе с Xlib в целом, можете <A href="/cdn-cgi/l/email-protection#1a6875786e5a6875786e756f7d727f6834797577">написать мне.</A>. <A name=a></A>
<H2>a. Ссылки</H2>
<UL>
  <LI><!--<A href="http://www.xfree86.org/">-->www.xfree86.org<!--</A>-->- домашняя страничка
  XFree86, open-source реализация X Window System
  <LI><!--<A href="http://tronche.com/gui/x/xlib/">-->Xlib Programming Manual
  (http://tronche.com/gui/x/xlib/)<!--</A>-->- замечательный ресурс для тех, кто
  работает с Xlib.
  <LI><!--<A href="http://www.x.org/about_x.htm">-->The X Protocol
  (http://www.x.org/about_x.htm)<!--</A>--> - информация об X протоколе на сайте
  www.x.org </LI></UL><A name=b></A>
<H2>b. Файлы</H2>
<UL>
  <LI>Примеры
  <UL>
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/Makefile.txt">-->Makefile
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/Makefile.txt)<!--</A>--> -
    для компиляции всех примеров
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/example1.cpp.txt">-->Example1
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/example1.cpp.txt)<!--</A>-->
    - создание простого окна с помощью Xlib
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/example2.cpp.txt">-->Example2
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/example2.cpp.txt)<!--</A>-->
    - использование класса <B>display</B>
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/example3.cpp.txt">-->Example3
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/example3.cpp.txt)<!--</A>-->
    - использование класса <B>window</B>
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/example4.cpp.txt">-->Example4
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/example4.cpp.txt)<!--</A>-->
    - обработка событий с помощью <B>event_dispatcher</B>
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/example5.cpp.txt">-->Example5
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/example5.cpp.txt)<!--</A>-->
    - рисование линий и текста с помощью класса <B>graphics_context</B>
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/example6.cpp.txt">-->Example6
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/example6.cpp.txt)<!--</A>-->
    - наша кнопка в действии </LI></UL>
  <LI>классы xlib++
  <UL>
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/shapes.hpp.txt">-->shapes.hpp
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/shapes.hpp.txt)<!--</A>-->
    - содержит различные классы фигур
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/character.hpp.txt">-->character.hpp,
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/character.hpp.txt)<!--</A>-->
    <!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/color.hpp.txt">-->color.hpp
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/color.hpp.txt)<!--</A>--> -
    вспомогательные классы
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button_base.hpp.txt">-->command_button_base.hpp
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button_base.hpp.txt)<!--</A>-->
    - абстрактный класс <B>command_button_base</B>
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txt">-->command_button.hpp
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/command_button.hpp.txt)<!--</A>-->
    - класс <B>command_button</B>
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/event_dispatcher.hpp.txt">-->event_dispatcher.hpp
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/event_dispatcher.hpp.txt)
    <!--</A>-->- класс <B>event_dispatcher</B> для обработки событий
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/display.hpp.txt">-->display.hpp
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/display.hpp.txt)<!--</A>-->
    - класс <B>display</B>
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/exceptions.hpp.txt">-->exceptions.hpp
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/exceptions.hpp.txt)<!--</A>-->
    - различные классы исключений
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/graphics_context.hpp.txt">-->graphics_context.hpp
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/graphics_context.hpp.txt)<!--</A>-->
    - класс для рисования <B>graphics_context</B>
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/window_base.hpp.txt">-->window_base.hpp
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/window_base.hpp.txt)<!--</A>-->
    - абстрактный класс <B>window_base</B>
    <LI><!--<A
    href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/window.hpp.txt">-->window.hpp
    (http://gazette.linux.ru.net/lg78/articles/misc/tougher/window.hpp.txt)<!--</A>-->
    - класс <B>window</B> для создания окна </LI></UL>
  <LI><!--<A
  href="http://gazette.linux.ru.net/lg78/articles/misc/tougher/COPYING.txt">-->COPYING
  (http://gazette.linux.ru.net/lg78/articles/misc/tougher/COPYING.txt)<!--</A>--> -
  Информация об авторском праве на исходные тексты в данной статье </LI></UL>
<HR noShade SIZE=2>

<H4>Rob Tougher</H4>
<P><EM>Роб -- пишущий на C++ программист из Нью-Йорка. В свободное от работы
время его можно найти прогуливающимся по пляжу со своей девушкой Николь (Nicole)
и их собакой Холли (Halley). </EM></P>
<HR noShade SIZE=2>

<H5 align=center>Copyright (C) 2002, Rob Tougher.<BR>Copying license <A
href="/http://www.linuxgazette.com/copying.html">http://www.linuxgazette.com/copying.html</A><BR>Published
in Issue 78 of <I>Linux Gazette</I>, May 2002 </H5>
<HR noShade SIZE=2>

<P><I>Команда переводчиков: <BR>Владимир Меренков, Александр Михайлов, Иван
Песин, Сергей Скороходов, Александр Саввин, Роман Шумихин, Александр Куприн,
Андрей Киселев</I></P>

  </div>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script></body>
</html>
